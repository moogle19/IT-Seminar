\documentclass[a4paper, 12pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{cite}
\geometry{a4paper, top=25mm, left=25mm, right=25mm, bottom=25mm}

\title{Seminar IT-Sicherheit}
\author{Kevin Seidel \\ Studiengang Informatik \\ Matrikelnummer: 943147}

\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{1.5cm}
\begin{Large}
\textbf{Universität Osnabrück}
\end{Large}

\noindent\hrulefill
\\[3.5cm]
SEMINARARBEIT \\[1cm]m
zum Seminar \\[1cm]
\textbf{IT-Sicherheit} \\[1.5cm]
im Sommersemester 2013 \\[1.5cm]
Thema: \\[0.5cm]
\textbf{IPv6 Privacy Extensions} \\[2cm]
Erstellt am 10.05.2013
\end{center}
\vfill
\begin{flushleft}
Vorgelegt von: 
\hfill \parbox{46mm}{Kevin Seidel} \\
\hfill \parbox{46mm}{943147} \\
\hfill \parbox{46mm}{Falkenstraße 43} \\
\hfill \parbox{46mm}{49124 Georgsmarienhütte}
\end{flushleft}
\end{titlepage}

\newpage

\pagenumbering{Roman}
\setcounter{page}{2}
\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Einleitung}
Diese Seminararbeit behandelt das Internet Protocol version 6 und dabei insbesondere die Vergabe und Erzeugung der Netzwerkadressen.
Das Internet Protocol version 6, oder kurz IPv6, ist der Nachfolger des Internet Protocol version 4 (IPv4), welches aktuell in den meisten Netzwerken verwendet wird.
Noch ist IPv6 nicht sehr verbreitet und nur etwa ein Prozent des weltweiten Internetverkehrs wird über dieses Protokol abgewickelt.
Doch durch zunehmende Unterstützung der Netzwerkgeräte und der Internetanbieter verbreitet sich IPv6 immer weiter und wird in Zukunft IPv4 ablösen.
Der Wechsel zu IPv6 wurde nötig, da der Adressraum von IPv4 langsam aufgebraucht war und im Jahr 2011 die letzten IPv4-Adressen von der Internet Assigned Numbers Authority vergeben wurden.
Dies liegt vorallem an der starken Anstieg von netzwerkfähigen Geräten in den letzten Jahren.
Der Adressraum von IPv6 ist deshalb so gewählt, dass er auch in den nächsten Jahrzehnten für jedes Netzwerkgerät eine Adresse zur Verfügung stellen kann. 


\newpage


Diese Arbeit beschäftigt sich mit der Funktionsweise und den damit verbundenen Vorteilen und Nachteilen der Stateless Address Autoconfiguration und der Privacy Extentions, welche beim Internet Protocol Version 6 zum Einsatz kommen.
IPv6 ist ein sehr spannendes Thema, da es in letzter Zeit vermehrt Beachtung findet und sich fortlaufend stärker verbreitet. 
Zukünftig soll das neue Protokoll von allen Geräten verstanden und genutzt werden, da durch die Vielzahl der Netzwerkgeräte der Adressraum von IPv4 langsam aufgebraucht ist.
Da immer mehr alltägliche Geräte netzwerkfähig werden, ist es daher in Zukunft nötig, ein Standard einzuführen, welcher diese Entwicklung berücksichtigt und erlaubt.
Bei der Entwicklung von IPv6 wurde darauf geachtet, eine möglichst einfache und schnelle Konfiguration der einzelnen Geräte zu ermöglichen.
Wo bei IPv4 noch eine manuelle Adressvergabe gefordert wurde oder ein DHCP-Server von nöten war, wird dies bei der Verwendung von IPv6 nicht mehr nötig.
Denn nun sind die Geräte selbst im Stande sich eigene IP-Adresse zu generieren, was vieles vereinfacht, da es ohne eine Eingabe des Nutzers oder vorherige Konfiguration geschieht.
Da es nun aber möglich ist, dass jedem Gerät der Erde eine eindeutige IP zugeordnet wird, birgt das neue Protokoll auch Risiken.

Die später entwickelten Privacy Extentions probieren diesen Risiken entgegenzuwirken, indem, statt einer statischen IP-Adresse, dynamische IP-Adressen generiert werden und so die Privatssphäre und Sicherheit der Nutzer erhöht.
Dies verhindert eine feste Zuordnung von einem Gerät zu der dazugehörigen IP-Adresse, was zum Beispiel für speziell platzierte Werbung oder Angriff auf das Gerät genutzt werden könnte.

\newpage

\section{Das Internet Protocol Version 6}
\subsection{Warum IPv6?}
Durch den starken Anstieg von Netzwerkgeräten in den vergangen Jahren, ist es nötig geworden, einen größeren Adressraum zu schaffen.
Das Internet Protocol (IP) Version 4 stellt, aufgrund der Adressgröße von 32 Bits, nur einen Adressraum von $2^{32}$ Adressen zur Verfügung, was in etwa 4,3Mrd. Adressen entspricht. Da diese jedoch mittlerweile alle vergeben sind, ist es notwendig geworden einen größeren Adressraum zu schaffen.


IP Version 6 setzt deshalb auf eine Adresslänge von 128 Bits, wodurch sich der Adressraum enorm vergrößert (etwa $3.4*10^{38}$ Adressen). 

Eine weitere Veränderung von IP Version 6(IPv6) gegenüber IP Version 4 (IPv4) ist ein Header mit festgelegter Größe, welcher die zwingend notwendigen Informationen enthält. Für zusätzliche Informationen gibt es einen Extention Header, welcher jedoch nur bei Bedarf genutzt wird.

\subsection{Aufbau einer IPv6-Adresse}
Die IPv6-Adresse unterscheiden sich deutlich von den bisher verwendeten IPv4-Adressen. IPv4-Adressen haben eine Größe von 32 Bits und werden meist in der ''dotted decimal notation'', das heißt in vier Blöcken von Dezimalzahlen zwischen 0 und 255, welche durch einen Punkt separiert werden, dargestellt. Dadurch lassen sich $2^{32}$ (ca. 4,3 Mrd.) verschiedene Adressen darstellen.
Durch die Verwendung von IPv6-Adressen erhöht sich die Anzahl der Adressen drastisch, da man hier eine Adresslänge von 128 Bits verwendet, womit die Größe des Adressraumes auf $2^{128}$ angehoben wird. Da eine Darstellung dieser Adressen in ''dotted decimal notation'' aus 16 Blöcken bestehen würde und damit sehr schwer zu lesen wäre, entschloss man sich dazu die IPv6-Adressen in 8 Blöcken zu je 4 Hexadezimalziffern zusammenzufassen. Diese Blöcke werden, durch einen Doppelpunkt getrennt, notiert.


\begin{figure}[h]
	\centering
	$2001:0db8:1aAa:0000:CCcc:0000:0000:0D01$
	\caption{Beispiel einer IPv6-Adresse.}
\end{figure}


Da diese Adressen im Vergleich zu IPv4-Adressen immernoch relativ lang und unübersichtlich sind, gibt es mehrere Möglichkeiten eine IPv6-Adresse zu verkürzen.
So wird im \cite{rfc4291} vereinbart, dass man ein oder mehrere aufeinanderfolgende Blöcke, welche nur Nullen beinhalten durch ''::'' verkürzen kann. Dies jedoch nur einmal pro Adresse.
Ausserdem ist es möglich auf führende Nullen innerhalb eines Blockes zu verzichten. \\


In \cite{rfc5952} wird eine Empfehlung für eine etwas striktere Darstellung von IPv6-Adressen gemacht.
So ist es dort vorgeschrieben innerhalb von Adressen nur Kleinbuchstaben zu verwenden. Dies dient der besseren Lesbarkeit und verhindert eine versehentliche Verwechselung von $8$ und $B$ sowie $0$ und $D$, die bei gemischter Groß- und Kleinschreibung oder durchgängiger Großschreibung entstehen könnte.

Des Weiteren müssen führende Null innerhalb eines Blockes ausgelassen werden und Blöcke, welche nur aus Nullen bestehen, durch eine einzelne Null repräsentiert werden.

Ausserdem ist es nun nicht mehr erlaubt einzelne Null-Felder durch ''::'' zu repräsentieren. 
Diese Schreibweise ist nurnoch auf mehrere aufeinanderfolgende Null-Felder anwendbar und muss in dem Fall auch genutzt werden.
Gibt es mehrer Möglichkeiten Felder durch ''::'' zu verkürzen, muss das mit dem größten Nutzen, das heißt mit den meisten aufeinanderfolgenden Nullen, gewählt werden. 
Gibt es mehrere gleichgroße Möglichkeiten, ist die erste zu wählen.


\begin{figure}[h]
	\centering
	$2001:db8:1aaa:0:cccc::d01$
	\caption{Beispieladresse aus Abb. 1 unter Berücksichtigung der Empfehlung}
\end{figure}

Durch die Befolgung dieser Regeln zu Darstellung von IPv6-Adressen in Textform wird die Lesbarkeit stark verbessert.

Die Netzmasken werden bei IPv6 durch Suffixe dargestellt, das heißt die Anzahl der Einsbits in der Netzmaske wird, abgetrennt durch einen Schrägstrich, hinten an die Adresse angehangen.
Eine Notation der Netzmaske als Adresse, wie in IPv4 üblich, ist nun nichtmehr vorgesehen.


\begin{figure}[h]
	\centering
	$2001:db8:1aaa:0:cccc::d01/64$
	\caption{Beispieladresse aus Abb. 2 mit Netzmaske}
\end{figure}

Durch diese Netzmaske wird angegeben, welcher Teil der Adresse das Netzwerk identifiziert und welcher Teil das Interface repräsentiert. Der vordere Teil der Adresse, auch Präfix genannt, dient dabei zur Bestimmung des Netzes.
Der hintere Teil, Interface Identifier genannt, dient zur Indentifizierung eines Gerätes im Netz.
Beim Beispiel in Abbildung 3 wäre der Präfix 2001:db8:1aaa:0::/64 und der Interface Identifier ::cccc:0:0:d01/64.


\subsection{Vergabe von IPv6-Adressen}
Bei der Vergabe von IPv6-Adressen in einem Netzwerk gibt es mehrere Vorgehensweisen. Zum einen die manuelle Vergabe von Adressen, was in kleinen Netzen schnell und einfach funktioniert, bei größeren Netzen jedoch einen enormen Aufwand bedeutet. 
Eine Alternative für größere Netze wäre die Verwendung des Dynamic Host Configuration Protocols (DHCP), welche schon für IPv4 existiert.
Für IPv6 gibt es eine angepasste Version mit dem Namen DHCPv6, welches, identisch zum klassischen DHCP, dynamisch Adressen an im Netzwerk befindliche Interfaces verteilt und die Adressen auf dem DHCP-Server speichert. 
Durch die Speicherung der Adressen handelt es sich dabei um eine Stateful Address Configuration im Gegensatz zur letzten Möglichkeit, der Stateless Address Autoconfiguration. 
Diese erzeugt IPv6-Adressen direkt auf dem Gerät, welches diese später verwendet. Dadurch kann komplett auf einen DHCP-Server oder manuelle Konfiguration verzichtet werden.
Ausserdem ist auch eine Kombination aus DHCP und Stateless Address Autoconfiguration möglich, wobei das Netzwerkgerät seine IP-Adressen selbst generiert, diese aber auch auf dem DHCP-Server gespeichert wird.
Im folgenden wird die Stateless Address Autoconfiguration genauer betrachtet.

\newpage

\section{Stateless Address Autoconfiguration}
Die Stateless Address Autoconfiguration ist ein Verfahren zur eigenständigen Erzeugung von IP-Adressen auf Netzwerkgeräten.
Dies ermöglicht eine einfache und konfigurationslose Einrichtung von Netzwerken, da zum Beispiel auf manuelle Adressvergabe oder den Einsatz von DHCP-Servern verzichtet werden kann.
Selbst bei mehreren verbundenen Netzwerken ist ein DHCP-Server nicht nötig, da mittels Router Advertisements, welche die notwendigen Informationen über das Netzwerk enthalten, die einzelnen Adressen für die Netze und deren Subnetze vergeben werden können.


\subsection{Funktionsweise der Stateless Address Autoconfiguration}
Für die Erzeugung einer globalen IPv6-Adresse sind mehrere Schritt nötig, welche im folgenden genauer erörtert werden.
Der Autokonfigurationsprozess wird automatisch mit der Aktivierung des Netzwerkgerätes gestartet.
Dazu wird zuerst eine link-local Adresse erstellt. Diese erlaubt grundlegende Kommunikation im Netzwerk.
Sie  setzt sich aus einem festgelegtem Präfix für link-locale Adressen (fe80::/64) und dem gerätespezfischen Interface Identifier zusammen.
Die Interface Identifier wird in der Regel aus der Media Access Control(MAC)-Adresse des Netzwerkgerätes gebildet.
Um diese 48 Bits lange MAC-Adresse auf die für den Interface Identifier vorgesehene Länge von 64 Bits zu bringen, wird die MAC-Adresse in der Mitte geteilt und dort wird der Wert ''FF:FE'' eingesetzt. Ausserdem wird das siebte Bit von links invertiert, welche angibt, ob die MAC-Adresse global oder lokal administriert wird.

Bevor diese vorläufige Adresse, egal ob manuell zugewiesen oder durch DHCP oder Staless Address Autoconfiguration, an ein Interface gebunden wird, muss deren Eindeutigkeit im Netzwerk überprüft werden. Die geschieht mittels Duplicate Address Detection.
Einzige Ausnahmen eine Duplicate Address Detection sind Anycast Adressen oder eine explizite Deaktiverierung des Vorgangs.
Zur Überprüfung der Eindeutigkeit von Adresse werden sogenannte Neighbor Solicitations und Neighbor Advertisements verwendet. Neighbor Solicitations haben als Empfänger unsere generierte vorläufige Adresse und als Sender die nicht spezifizierte Adresse (::).
Um eine Antwort auf diese Nachricht zu erhalten ist es noch nötig, dass das Interface zunächst dem all-nodes Multicast, welcher einem Broadcast in IPv4 entspricht und an alle angebundenen Adressen verschickt, und dem solicited-node Multicast, welcher speziell für die Duplicate Address Detection zuständig ist, beitreten.
Falls nun schon ein Interface diese vorläufige Adresse besitzt, erhält es die Neighbor Solicitation und antwortet mit einem Neighbor Advertisement. 
Unser Interface empfängt dieses Neighbor Advertisement, wodurch es weiß, dass die vorläufige Adresse nicht eindeutig ist und damit nicht an das Gerät gebunden werden kann.

Falls das Interface während der Duplicate Address Detection eine Neighbor Solicitation von einem anderen Gerät erhält, versuchen zwei Geräte gleichzeitig die gleiche Adresse zu verwenden. In diesem Fall sollte keines der Geräte seine vorläufige Adresse an das Gerät binden. Es kann jedoch auch vorkommen, dass die Neighbor Solicitation von unserem Gerät kommt, falls der Multicast die Packete auch an den Sender zurückschickt.

Wenn die Duplicate Address Detection fehlschlägt und unser Interface Indentifier aus der Hardware-Adresse gebildet wurde, sollten alle IP Operationen eingestellt werden.
Falls kein Neighbor Advertisement zurück kommt, kann die Adresse an das Gerät gebunden werden undfür die zukünftige Kommunikation verwendet werden.

Nachdem die link-local Adresse gebildet wurde, ist es nun möglich eine globale Adresse zu generieren. Dies geht jedoch nur, falls sich ein Router im Netzwerk befindet, da hierfür sogenannte Router Advertisements nötig sind. Die Router Advertisements enthalten Informationen über das Netzwerk, wie zum Beispiel den zu verwendenden Präfix.
Sie werden vom Router automatisch in periodischen Abständen geschickt, können jedoch auch durch Router Solification angefragt werden.

Ein Gerät sendet also zuerst eine Router Solification und wartet auf ein Router Advertisement als Antwort. Nach einem vorgegebenen Zeitraum ohne Antwort wird dies nocheinmal ausgeführt. Dies geschieht so lange bis ein Router antwortet oder die vorgegebene Maximalanzahl von Anfragen erreicht ist. 
Antwortet der Router, wird aus dem in dem Router Advertisement enthaltenen Präfix und dem vom Gerät vorher gebildeteten Interface Identifier eine globale Adresse gebildet.
Diese wird nun für den gesamten Netzwerkverkehr genutzt, wobei die link-locale Adress immernoch ihre Gültigkeit besitzt.


\newpage
\subsection{Probleme der Stateless Address Autoconfiguration}
Ein Problem bei der Stateles Address Autoconfiguration entsteht durch die Verwendung eines konstanten Interface Identifiers für die IP-Adresse. 
Da der Interface Identifier in den meisten Fällen aus der MAC-Adresse generiert wird, bleibt dieser über die gesamte Lebensdauer des Netzwerkgerätes konstant und änder sich selbst bei einem Wechsel des Netzwerkes nicht. 
Das heißt, selbst wenn der Präfix der IPv6-Adresse wechselt, lässt sich das Gerät, und damit meist auch der Nutzer, über den Interface Identifier mit sehr großer Trefferwahrscheinlichkeit zurückverfolgen.
So lässt sich beispielsweise mittels eines Netzwerksniffers bestimmen, wann ein Gerät kommuniziert hat, mit wem es kommuniziert hat und ,durch den Präfix der IPv6-Adresse, in welchem Netz es sich befand.
Besonders problematisch ist dies bei mobilen Geräten, wie zum Beispiel Smartphones oder Laptops, welche oft ihren Standort ändern.
So können deren Bewegungen sehr leicht verfolgt werden, da sich zwar der Präfix der Adresse bei einem Netzwechsel ändert, der Interface Identifier jedoch konstant bleibt. 
Es kann als bestimmt werden, wann sich eine Gerät in einem bestimmten Netzwerk aufgehalten hat, wie viel Zeit er dort verbracht hat und zu wem er sich verbunden hat.

Dies ermöglicht nicht nur gezieltere Angriffe sonder auch die Platzierung von Werbung, welche auf den jeweiligen Benutzer abgestimmt ist, ohne das dieser es weiß.

Ein weiters Problem was bei der Nutzung von MAC-Adressen für der Erzeugung des Interface Identifier entsteht, ist die dadurch entstehende Möglichkeit, die Hardware des Gerätes zu bestimmen. Da die MAC-Adressen eindeutige Herstellerkennungen enthalten, lässt sich die darunterliegende Hardware leichter bestimmen und dadurch gezielt angreifen. So kann man beispielsweise anhand der MAC-Adresse Apple Geräte erkennen und in Folge dessen gezielte Angriffe auf das verwendete Betriebssystem durchführen.

Ein Ansatz zur Lösung des Problems geben die Privacy Extentions für IPv6.


\section{IPv6 Privacy Extensions}
Durch den Einsatz der IPv6 Privacy Extensions sollen die voher beschriebenen Probleme der Stateless Address Autoconfiguration gelöst werden.
Dies geschieht dadurch, dass der Interface Identifier nicht mehr nur aus der bearbeiteten MAC-Adresse besteht, und damit über die gesamte Lebensdauer des Gerätes gleich bleibt, sonder dynamisch erzeugt wird.
Dadurch wird eine Zuordnung von einer IPv6-Adresse zu einem bestimmten Gerät nahezu unmöglich und die vorher beschriebenen Probleme mit der Privatsphäre werden gelöst.


Da durch die Privacy Extentions jedoch nur der Interface Identifier geändert wird, ist die Gefahr einer konstanten Zuordnung einer Adresse zu einem Gerät nicht komplett gelöst.
Jedes Netzwerk bekommt seinen eigenen Präfix, welcher ebenfalls konstant sein kann. 
So lässt sich bei kleinen Netzwerken, bestehend aus wenigen oder sogar nur einem Gerät, über den Präfix eine relativ genaue Zuordnung der Adresse zu einem Gerät machen und das obwohl der Interface Identifier ständig wechselt.
Bei Adressen, welche bei einem Domain Name System(DNS) - Server registriert sind, bringt eine Verwendung der Privacy Extentions ebenfalls wenig, da bei wechselnder IP der DNS-Name meist gleich bleibt.
Da über den DNS-Namen eine eindeutige Zuordnung möglich ist, hat der wechselnde Interface Identifier keinerlei Vorteile.
Es gibt jedoch auch Geräte, welche sowohl als Client, als auch als Server aggieren. 
Hier ist es möglich dem Gerät zwei IPv6-Adressen zuzuweisen. So kann die Serveradresse im DNS eingetragen sein und ist dadurch öffentlich erreichbar. Der Client hingegen bekommt eine private IPv6-Adresse, auf welche die Privacy Extentions angewand werden. Dabei muss jedoch gegeben sein, dass man keinerlei Zusammenhang zwischen den beiden Adressen herstellen kann. Es ist daher nötig bei der Generierung eine Zufallsvariable mit einzubeziehen, um dies zu verhindern.




\subsection{Einsatz der Privacy Extentions}
Das Ziel der Privacy Extensions ist es, bei erhöhter Sicherheit und Privatsphäre, die gleiche einfache Handhabung und automatische Adressegenerierung wie bei der Stateless Address Autoconfiguration sicherzustellen.
Es soll somit ermöglicht werden, aus dem zufällig erstellten Interface Identifier verschiedene Adressen, mit unserschiedlichen Präfixen, zu erstellen.
Eine andere Möglichkeit ist die Generierung eines spezifischen Interface Identifiers für jeden Präfix, um die keinen Zusammenhang zwischen den einzelnen Adressen herzustellen.
Dies führt jedoch möglicherweise zu einer Performancereduzierung.
Aus diesem zufälligen Interface Identifier sollen sich zudem keine zukünftigen oder vergangenen Interface Identifier ableiten oder berechnen lassen.


\subsection{Generierung des zufälligen Interface Identifiers}
Bei der Generierung des randomisierten Interface Identifiers gibt es zwei verschiedene Vorgehensweisen.
Die erste Vorgehensweise setzt einen persistenten Speicher für die Erzeugung des Interface Identifiers vorraus.
Diese Variante verzichtet auf die Generierung eine Zufallszahl bei der Erzeugung eines neuen Interface Identifiers.
Hier muss nur bei erster Inbetriebnahme eine Zufallszahl generiert werden.

Die zweite Methode wird bei nicht vorhandenem Speicher eingesetzt. Dort ist es nötig bei jeder neuen Erzeugung eines Interface Identifiers, auch eine neue Zufallszahl generieren.

Bei einem Gerät, welches nach der ersten Methode vorgeht und somit über persistenten Speicher verfügt, wird bei der ersten Inbetriebnahme eine 64 Bit Zufallszahl generiert. 
Diese sollte von hoher Qualität und damit schwer zu erraten sein. 
Bei dieser Methodik muss immer ein 64 Bit langes history value vorhanden sein. Dieses wird entweder, wie oben beschrieben, bei Erst-Start generiert oder wurde aus der vorherigen Erzeugung eines Interface Identifiers gespeichert.

Der eigentliche Vorgang der Erzeugung des Interface Identifiers beginnt damit, dass man das history value an den durch die Stateless Address Autoconfiguration erzeugten Interface Identifier anhängt.
Hiervon wird nun der Message-Digest Algorithm 5 (MD5)-Hash erzeugt, welcher 128 Bit lang ist.
Es ist jedoch auch möglich andere Hashingverfahren zu verwenden.
Für den Interface Identifier werden die linken 64 Bit verwendet und das siebte Bit wird auf 0 gesetzt, um die Adresse als lokal zu setzen.
Wie bei der Stateless Address Autoconfiguration werden auch hier die Adressen auf ihre Einzigartigkeit hin getestet.
Falls der Interface Identifier in einem reservierten Bereich liegt oder schon verwendet wird, ist es nötig ihn erneut zu generieren.
Dies geschieht unter Verwendung der rechten 64 Bit des zuvor errechneten MD5-Hashes als history value, welche an den Interface Identifier angehängt wird.
Falls kein Konflikt vorherscht werden die rechten 64 Bit des Hashes als history value auf den persistenten Speicher geschrieben.

Das Verfahren mit der Einbeziehung des statischen Interface Identifiers wird deshalb gewählt, damit es durch gleiche Zufallszahl-Generatoren nicht zu ständigen Konflikten kommt, falls zwei Geräte immer wieder die selben Zufallszahlen generieren.


Die zweite Methode, welche bei der Absenz von Speicher zur Anwendung kommt, wird ähnlich vorgehen.
Statt jedoch auf das history value zurückzugreifen, ist es nötig bei jeder neuen Generierung eines Interface Identifiers auch eine neue Zufallszahl zu generieren. 
Danach kann das Verfahren wie aus der ersten Methode angewand werden.

\newpage

\section{Mögliche Verbesserungen der Privacy Extentions}
Die Privacy Extentions sind zwar eine enorme Verbesserung gegenüber dem Standartverfahren der Stateless Address Autoconfiguration, jedoch nicht ohne weiteres Verbesserungspotenzial.
Da der Grad der Sicherheit beziehungsweise der Privatsphäre dort stark von dem Zeitintervall der Generierung eines neuen Interface Identifier abhängt.
Ausserdem bleibt auch hier der Interface Identifier bei einem Wechsel in ein anderes Netzwerk und damit bei einem neuen Adresspräfix, konstant. 
So lässt sich die Adresse immernoch ohne Probleme einem Client zuordnen. Dadurch wird ist es für mögliche Angreifer immernoch möglich ihn zu verfolgen und zuzuordnen.

Ein möglicher Verbesserungsvorschlag wird in \cite{Paper} gemacht. Dort wird eine Einbeziehung des Präfixes in die Erzeugung von Interface Identifiern vorgeschlagen.
Dadurch unterscheidet sich der Interface Identifiers eines Gerätes in verschiedenen Netzwerken, auch wenn sich die Ausgangszahl für die Generierung nicht verändert hat.

In dem Paper wird der Interface Identifier anhand des Präfixes und einer Zufallszahl gebildet, statt die MAC-Adresse mit einzubeziehen.
Dadurch wird die Sicherheit enorm erhöht.
Der Generator für die Zufallszahlen sollte zudem kryptographisch sicher sein, damit die vorhergegangenen und nachfolgenden Wert nicht erraten werden können.
Die Erzeugung des Interface Identifier erfolgt, wie bei den Privacy Extentions, über die Erstellung eines Hashes, diesmal jedoch über den Präfix und die Zufallszahl plus n.
Das n ist hierbei ein Offset, welcher bei Systemstart oder Wechsel der Zufallszahl auf 0 gesetzt wird und um eins inkrementiert wird, falls eine Adresskolision vorliegt.
Als Hashverfahren wird hier mindestens SHA-2, um die Berechnung der Zufallszahl bei Kenntnis der Adresse und des Präfixes zu vermeiden, da es deutlich schwerer zu knacken ist als MD5, welches bei den Privacy Extentions verwendet wird.

Für die Festlegung des Intervalles, in welchem die Zufallszahl erzeugt wird, gibt es mehrere Möglichkeiten.
Zum einen ist eine zeitabhängige Änderung wie bei den Privacy Extentions möglich.
Hierbei ist jedoch die Wahl des Wertes entscheidet. So muss das Intervall so groß gewählt werden, dass die bestehenden Verbindungen nicht zu stark beeinträchtigt werden, da bei Wechsel des Interface Identifiers und dem damit verbundenen Wechsels der IP-Adresse, die bestehende Verbindung beendet wird.
Das Interval sollte jedoch auch klein genug sein, um eine mögliche Zuordnung einer IP-Adresse zu einem Gerät zu machen.

Eine andere Möglichkeit, welche dieses Problem umgeht, ist die Generierung der Zufallszahl, wenn sich das Gerät mit einem Netzwerk verbindet. Dies geschieht entweder beim Start des Gerätes oder bei einem Wechsel des Netzwerks. 
Da bei einem Wechsel des Netzwerkes sowieso alle bestehenden Verbindungen beendet werden, gibt es keine Probleme durch zu schnell wechselnde Adressen.
Ausserdem ist der Zeitraum, in dem eine neue Zufallszahl generiert wird klein genug, um einen ausreichenden Grad an Sicherheit zu gewährleisten.

Eine ähnliche Lösung ist die Generierung der Zufallszahl bei jedem Systemneustart. Dadurch werden ebenfalls ungewollte Verbindungsabbrüche verhindert, die Sicherheit dieser Lösung ist jedoch stark von der Häufigkeit der Neustarts abhängig. 

Eine Möglichkeit welche vorallem bei Firmennetzwerken intersessant ist, ist die Generierung der Zufallszahl bei der Installation des Betriebssystems. Dadurch bleibt der Interface Identifier in einem Netzwerk bei jeder Anmeldung gleich, wechselt man jedoch in eine anders Netzwerk, wird durch die Einbeziehung des Präfixes, ein anderer Interface Identifier verwendet. 
Ein Tracking des Gerätes durch mehrere Netzwerke wird so zwar verhindet, eine IP-Adresse lässt sich denoch dem dazugehörigen Client im passenden Netzwerk zuordnen.

Die letzte Möglichkeit ist die Generierung der Zufallszahl vom Nutzer anstoßen zu lassen. Dies umgeht ebenfalls das Risiko ungewollter Verbindugsabbrüche, kann jedoch auch zu Sichheitsrisiken führen, falls der Nutzer es nicht weiß oder vergisst.

Daher empfehlen die Autoren, die Zufallszahl bei jeder neuen Verbidnung zu einem Netzwerk zu erzeugen, da dies den besten Kompromiss zwischen Nutzbarkeit und Sicherheit darstellt.


\newpage
\section{Fazit}
Bei der Betrachtung der Stateless Address Autoconfiguration und der Privacy Extentions zeigt sich, dass die Verwendung von IPv6 nicht nur Vorteile mit sich bringt, sondern auch einige Risiken birgt.
Dies zeigt sich vor allem durch die Möglichkeit jedem Gerät auf der Welt eine eindeutige IPv6-Adresse zuzuweisen, was die Geräte leichter überwachbar macht.
Diese Schwachstelle wird durch die Privacy Extentions größtenteils geschlossen, aber durch die weitere Verbreitung und Verwendung von IPv6 werden in den kommenden Jahren mit großer Wahrscheinlichkeit weitere Risiken und Lücken aufgedeckt. 
So werden auch jetzt schon Verbesserungen für die Privacy Extentions empfohlen, da diese noch keine ideale Lösung sind.
Bis sich IPv6 schlussendlich durchsetzen wird, dauert es noch einige Jahre. Da noch viele ältere Netzwerkgeräte verwendet werden, ist eine sofortige Umstellung nicht möglich und muss daher schrittweise erfolgen. 




\newpage

\section{Quellen}
RFC 5952
RFC 3513
RFC 4941
RFC 4291
https://supportforums.cisco.com/docs/DOC-24485
\bibliography{rfc,sources}{}

\bibliographystyle{amsalpha}
\end{document}

\end{document}
